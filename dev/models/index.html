<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · Recommenders.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://yng87.github.io/Recommenders.jl/models/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Recommenders.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Models</a><ul class="internal"><li><a class="tocitem" href="#Common-interfaces"><span>Common interfaces</span></a></li><li><a class="tocitem" href="#Most-Popular"><span>Most Popular</span></a></li><li><a class="tocitem" href="#Item-kNN"><span>Item kNN</span></a></li><li><a class="tocitem" href="#Matrix-Factorization"><span>Matrix Factorization</span></a></li><li><a class="tocitem" href="#Bayesian-Personalized-Ranking"><span>Bayesian Personalized Ranking</span></a></li><li><a class="tocitem" href="#Sparse-Linear-Machine"><span>Sparse Linear Machine</span></a></li><li><a class="tocitem" href="#Random-Walk"><span>Random Walk</span></a></li></ul></li><li><a class="tocitem" href="../metrics/">Metrics</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/yng87/Recommenders.jl/blob/master/docs/src/models.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h1><ul><li><a href="#Models">Models</a></li><ul><li><a href="#Common-interfaces">Common interfaces</a></li><li><a href="#Most-Popular">Most Popular</a></li><li><a href="#Item-kNN">Item kNN</a></li><li><a href="#Matrix-Factorization">Matrix Factorization</a></li><li><a href="#Bayesian-Personalized-Ranking">Bayesian Personalized Ranking</a></li><li><a href="#Sparse-Linear-Machine">Sparse Linear Machine</a></li><li><a href="#Random-Walk">Random Walk</a></li></ul></ul><h2 id="Common-interfaces"><a class="docs-heading-anchor" href="#Common-interfaces">Common interfaces</a><a id="Common-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Common-interfaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.AbstractRecommender" href="#Recommenders.AbstractRecommender"><code>Recommenders.AbstractRecommender</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRecommender</code></pre><p>Abstract struct for all recommendation models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/base_recommender.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.evaluate_u2i-Tuple{AbstractRecommender, Any, Any, Recommenders.MeanMetric, Int64}" href="#Recommenders.evaluate_u2i-Tuple{AbstractRecommender, Any, Any, Recommenders.MeanMetric, Int64}"><code>Recommenders.evaluate_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_u2i(model, train_table, test_table, metric, n; kwargs...)</code></pre><p>Perform <code>fit!</code> for <code>model</code> on <code>train_table</code>, predict for each user in <code>test_table</code>, and evaluate by <code>metric</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractRecommender</code>: model to evaluate.</li><li><code>train_table</code>: any <code>Tables.jl</code>-compatible data for train.</li><li><code>test_table</code>: any <code>Tables.jl</code>-compatible data for test.</li><li><code>metric</code>: evaluation metrics, <code>MeanMetric</code> or collection of <code>MeanMetric</code>.</li><li><code>n::Int64</code>: number of retrieved items.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>drop_history::Bool</code>: whether to drop already consumed items from predictions.</li><li><code>col_user</code>: name of user column in <code>table</code></li><li><code>col_item</code>: name of item column in <code>table</code></li><li>any model-dependent arguments.</li></ul><p><strong>Return</strong></p><p>Evaluated metrics for <code>test_table</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/base_recommender.jl#LL65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{AbstractRecommender, Any}" href="#Recommenders.fit!-Tuple{AbstractRecommender, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::AbstractRecommender, table; kwargs...)</code></pre><p>Train <code>model</code> by <code>table</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: concrete type under <code>AbstractRecommender</code></li><li><code>table</code>: any <code>Tables.jl</code>-compatible data for train.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>col_user</code>: name of user column in <code>table</code></li><li><code>col_item</code>: name of item column in <code>table</code></li><li>and other model-dependent arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/base_recommender.jl#LL9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{AbstractRecommender, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{AbstractRecommender, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model, userid, n; kwargs...)</code></pre><p>Make recommendations to user (or users). When <code>userid</code> is a collection of raw user ids, this function performs parallel predictions by <code>Threads.@threads</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractRecommender</code>: trained model.</li><li><code>userid:</code>: user id to get predictions. type is <code>AbstractString</code>, <code>Int</code> or their collection.</li><li><code>n::Int64</code>: number of retrieved items.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>drop_history::Bool</code>: whether to drop already consumed items from predictions.</li><li>and other model-dependent arguments.</li></ul><p><strong>Return</strong></p><p>Vector of predicted items, ordered by descending score.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/base_recommender.jl#LL28-L44">source</a></section></article><h2 id="Most-Popular"><a class="docs-heading-anchor" href="#Most-Popular">Most Popular</a><a id="Most-Popular-1"></a><a class="docs-heading-anchor-permalink" href="#Most-Popular" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.MostPopular" href="#Recommenders.MostPopular"><code>Recommenders.MostPopular</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MostPopular()</code></pre><p>Non-personalized baseline model which predicts n-most popular items in the corpus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/most_popular.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{MostPopular, Any}" href="#Recommenders.fit!-Tuple{MostPopular, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::MostPopular, table; col_user = :userid, col_item = :itemid)</code></pre><p>Fit most popular model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/most_popular.jl#LL13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{MostPopular, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{MostPopular, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::MostPopular, userid::Union{AbstractString,Int}, n::Int64; drop_history::Bool = false)</code></pre><p>Make <code>n</code> prediction to user by most popular model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/most_popular.jl#LL31-L35">source</a></section></article><h2 id="Item-kNN"><a class="docs-heading-anchor" href="#Item-kNN">Item kNN</a><a id="Item-kNN-1"></a><a class="docs-heading-anchor-permalink" href="#Item-kNN" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.ItemkNN" href="#Recommenders.ItemkNN"><code>Recommenders.ItemkNN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ItemkNN(k::Int64, shrink::Float64, weighting::Union{Nothing,Symbol}, weighting_at_inference::Bool, normalize::Bool, normalize_similarity::Bool)</code></pre><p>Item-based k-nearest neighborhood algorithm with cosine similarity. The model first computes the item-to-item similarity matrix</p><p class="math-container">\[s_{ij} = \frac{\bm r_i \cdot \bm r_j}{\|\bm r_i\|\|\bm r_j\| + h}\,,\]</p><p>where <span>$r_{i,u}$</span> is rating for item <span>$i$</span> by user <span>$u$</span> and <span>$h$</span> is the shrink parameter to suppress the contributions from items with a few ratings.</p><p><strong>Constructor arguments</strong></p><ul><li><code>k</code>: size of the nearest neighbors. Only the k-most similar items to each item are stored, which reduces sparse similarity maxrix size, and also make better predictions.</li><li><code>shrink</code>: shrink paramerer explained above.</li><li><code>weighting</code>: if set to <code>:ifidf</code> or <code>:bm25</code>, the raw rating matrix is weighted by TF-IDF or BM25, respectively, before computing similarity. If not necessary, just set <code>nothing</code>.</li><li><code>weighting_at_inference</code>: to use above weighting at inference time, only relevant for BM25.</li><li><code>normalize_similarity</code>: if set to <code>true</code>, normalize each column of similarity matrix. See the reference for detail.</li></ul><p><strong>References</strong></p><p>M. Deshpande and G. Karypis (2004), <a href="https://doi.org/10.1145/963770.963776">Item-based top-N recommendation algorithms</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/item_knn.jl#LL1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{ItemkNN, Any}" href="#Recommenders.fit!-Tuple{ItemkNN, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::ItemkNN, table; col_user = :userid, col_item = :itemid, col_rating = :rating)</code></pre><p>Fit the <code>ItemkNN</code> model. <code>col_rating</code> specifies rating column in the <code>table</code>, which will be all unity if implicit feedback data is given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/item_knn.jl#LL58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{ItemkNN, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{ItemkNN, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::ItemkNN, userid::Union{AbstractString,Int}, n::Int64; drop_history = false)</code></pre><p>Recommend top-<code>n</code> items for user by <code>ItemkNN</code>. The predicted rating of item <span>$i$</span> by user <span>$u$</span> is computed by</p><p class="math-container">\[
\hat{r}_{i, u} = \sum_{j} s_{ij} r_{j, u}\,,\]</p><p>where <span>$r_{j, u}$</span> is the actual user rating while <span>$\hat{r}_{i, u}$</span> is the model prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/item_knn.jl#LL102-L112">source</a></section></article><h2 id="Matrix-Factorization"><a class="docs-heading-anchor" href="#Matrix-Factorization">Matrix Factorization</a><a id="Matrix-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Factorization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.ImplicitMF" href="#Recommenders.ImplicitMF"><code>Recommenders.ImplicitMF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitMF(dim::Int64, use_bias::Bool, reg_coeff::Float64)</code></pre><p>Matrix factorization model for implicit feedback. The predicted rating for item <span>$i$</span> by user <span>$u$</span> is expreseed as</p><p class="math-container">\[\hat r_{ui} = \mu + b_i + b_u + \bm u_u \cdot \bm v_i\,,\]</p><p>Unlike the model for explicit feedback, the model treats all the (user, item) pairs in the train dataset as positive interaction with label 1, and sample negative (user, item) pairs from the corpus. Currently only the uniform item sampling is implemented. The fitting criteria is the ordinary logloss function</p><p class="math-container">\[    L = -r_{ui}\log(\hat r_{ui}) - (1 - r_{ui})\log(1 - \hat r_{ui}).\]</p><p><strong>Constructor arguments</strong></p><ul><li><code>dim</code>: dimension of user/item vectors.</li><li><code>use_bias</code>: if set to false, the bias terms (<span>$\mu$</span>, <span>$b_i$</span>, <span>$b_u$</span>) are set to zero.</li><li><code>reg_coeff</code>: <span>$L_2$</span> regularization coefficients for model parameters.</li></ul><p><strong>References</strong></p><p>For instance, Rendle et. al. (2020), <a href="http://arxiv.org/abs/2005.09683">Neural Collaborative Filtering vs. Matrix Factorization Revisited </a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/implicit_mf.jl#LL1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{ImplicitMF, Any}" href="#Recommenders.fit!-Tuple{ImplicitMF, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::ImplicitMF, table; callbacks = Any[], col_user = :userid, col_item = :item_id, n_epochs = 2, learning_rate = 0.01, n_negatives = 1, verbose = -1)</code></pre><p>Fit the <code>ImplicitMF</code> model by stochastic grandient descent (with no batching).</p><p><strong>Model-specific arguments</strong></p><ul><li><code>n_epochs</code>: number of epochs. During one epoch, all the row in <code>table</code> is read once.</li><li><code>learning_rate</code>: Learing rate of SGD.</li><li><code>n_negatives</code>: Number of negative item samples per positive (user, item) pair.</li><li><code>verbose</code>: If set to positive integer, the training info is printed once per <code>verbose</code>.</li><li><code>callbacks</code>: Additional callback functions during SGD. One can implement, for instance, monitoring the validation metrics and the early stopping. See <a href="../utils/#Callbacks">Callbacks</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/implicit_mf.jl#LL82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{ImplicitMF, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{ImplicitMF, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::ImplicitMF, userid::Union{AbstractString,Int}, n::Int64; drop_history = false)</code></pre><p>Make predictions by using <span>$\hat r_{ui}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/implicit_mf.jl#LL177-L181">source</a></section></article><h2 id="Bayesian-Personalized-Ranking"><a class="docs-heading-anchor" href="#Bayesian-Personalized-Ranking">Bayesian Personalized Ranking</a><a id="Bayesian-Personalized-Ranking-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Personalized-Ranking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.BPR" href="#Recommenders.BPR"><code>Recommenders.BPR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BPR(dim::Int64, reg_coeff::Float64)</code></pre><p>Bayesian personalized ranking model. The model evaluates user-item triplet <span>$(u ,i ,j)$</span>, which expresses &quot;the user <span>$u$</span> prefers item <span>$i$</span> to item <span>$j$</span>. Here the following matrix factoriazation model is adopted to model this relation:</p><p class="math-container">\[p_{uij} = \bm u_u \cdot \bm v_i - \bm u_u \cdot \bm v_j\]</p><p><strong>Constructor arguments</strong></p><ul><li><code>dim</code>: dimension of user/item vectors.</li><li><code>reg_coeff</code>: <span>$L_2$</span> regularization coefficients for model parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/bpr.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{BPR, Any}" href="#Recommenders.fit!-Tuple{BPR, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::BPR, table; callbacks = Any[], col_user = :userid, col_item = :item_id, n_epochs = 2, learning_rate = 0.01, n_negatives = 1, verbose = -1)</code></pre><p>Fit the <code>BPR</code> model by stochastic grandient descent. Instead the learnBPR algorithm proposed by the original paper, the simple SGD with negative sampling is implemented.</p><p><strong>Model-specific arguments</strong></p><ul><li><code>n_epochs</code>: number of epochs. During one epoch, all the row in <code>table</code> is read once.</li><li><code>learning_rate</code>: Learing rate of SGD.</li><li><code>n_negatives</code>: Number of negative item samples per positive (user, item) pair.</li><li><code>verbose</code>: If set to positive integer, the training info is printed once per <code>verbose</code>.</li><li><code>callbacks</code>: Additional callback functions during SGD. One can implement, for instance, monitoring the validation metrics and the early stopping. See <a href="../utils/#Callbacks">Callbacks</a>.</li></ul><p><strong>References</strong></p><p>Rendel et. al. (2012), <a href="http://arxiv.org/abs/1205.2618">BPR: Bayesian Personalized Ranking from Implicit Feedback</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/bpr.jl#LL62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{BPR, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{BPR, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::BPR, userid::Union{AbstractString,Int}, n::Int64; drop_history = false)</code></pre><p>Make predictions by using <span>$\bm u_u \cdot \bm v_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/bpr.jl#LL148-L152">source</a></section></article><h2 id="Sparse-Linear-Machine"><a class="docs-heading-anchor" href="#Sparse-Linear-Machine">Sparse Linear Machine</a><a id="Sparse-Linear-Machine-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Linear-Machine" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.SLIM" href="#Recommenders.SLIM"><code>Recommenders.SLIM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SLIM(l1_ratio::Float64 = 0.5, λminratio::Float64 = 1e-4, k::Int = -1)</code></pre><p>Sparse linear machine for recommendation, modified with Elastic Net loss. The prediction is made by</p><p class="math-container">\[\hat r_{ui} = \sum_{j\neq i} w_{ij} r_{uj}\]</p><p>where <span>$r_{ui}$</span> is the actual rating for item <span>$i$</span> by user <span>$u$</span>, and <span>$\hat r_{ui}$</span> is the predicted value. <span>$w_{ij}$</span> is the model weght matrix. See Refs for algorithm details. SLIM uses <a href="https://github.com/JuliaStats/Lasso.jl"><code>Lasso.jl</code></a> for optimization.</p><p><strong>Constructor arguments</strong></p><ul><li><code>l1_ratio</code>: ratio of coefficients between <span>$L_1$</span> and <span>$L_2$</span> losses. <code>l1_ratio</code> <span>$\to 0$</span> means the Ridge regularization, while <code>l1_ratio</code> <span>$\to \infty$</span> the Lasso.</li><li><code>λminratio</code>: parameter which governs the strength of regularization. See the docs of <code>Lasso.jl</code>.</li><li><code>k</code>: the nearest neighborhood size, similar to <code>ItemkNN</code>. If <code>k</code> &lt; 1, the neigoborhood size is infinity.</li></ul><p><strong>References</strong></p><ul><li>X. Ning and G. Karypis (2011), <a href="http://glaros.dtc.umn.edu/gkhome/node/774">SLIM: Sparse Linear Methods for Top-N Recommender Systems</a></li><li>M. Levy (2013), <a href="https://www.slideshare.net/MarkLevy/efficient-slides">Efficient Top-N Recommendation by Linear Regression</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/slim.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{SLIM, Any}" href="#Recommenders.fit!-Tuple{SLIM, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::SLIM, table; col_user = :userid, col_item = :itemid, col_rating = :rating, cd_tol = 1e-7, nλ = 100)</code></pre><p>Fit the SLIM model.</p><p><strong>Model-specific arguments</strong></p><ul><li><code>cd_tol</code>: tolerance paramerer for convergence, see <code>Lasso.jl</code></li><li><code>nλ</code>: length of regularization path, see <code>Lasso.jl</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/slim.jl#LL45-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{SLIM, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{SLIM, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::SLIM, userid::Union{AbstractString,Int}, n::Int64; drop_history = false)</code></pre><p>Make predictions by SLIM model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/slim.jl#LL107-L111">source</a></section></article><h2 id="Random-Walk"><a class="docs-heading-anchor" href="#Random-Walk">Random Walk</a><a id="Random-Walk-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Walk" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Recommenders.Randomwalk" href="#Recommenders.Randomwalk"><code>Recommenders.Randomwalk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Randomwalk()</code></pre><p>Recommendation model using random walk with restart on user-item bipartite graph. Implemented algorithm is based on Pixie random walk.</p><p><strong>References</strong></p><p>C.  Eksombatchai (2018), <a href="http://dl.acm.org/citation.cfm?doid=3178876.3186183">Pixie: A System for Recommending 3+ Billion Items to 200+ Million Users in Real-Time</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/randomwalk.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.fit!-Tuple{Randomwalk, Any}" href="#Recommenders.fit!-Tuple{Randomwalk, Any}"><code>Recommenders.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(model::Randomwalk, table; col_user = :userid, col_item = :itemid)</code></pre><p>Build bipartite graph from <code>table</code>. One side of the graph collcets user nodes, and the others item nodes. If a user actions an item, an edge is added between them. The graph is undirected, and has no extra weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/randomwalk.jl#LL22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommenders.predict_u2i-Tuple{Randomwalk, Union{Int64, AbstractString}, Int64}" href="#Recommenders.predict_u2i-Tuple{Randomwalk, Union{Int64, AbstractString}, Int64}"><code>Recommenders.predict_u2i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict_u2i(model::Randomwalk, userid::Union{AbstractString,Int}, n::Int64; drop_history = false, terminate_prob = 0.1, total_walk_length = 10000, min_high_visited_candidates = Inf, high_visited_count_threshold = Inf, pixie_walk_length_scaling = false, pixie_multi_hit_boosting = false, aggregate_function = sum)</code></pre><p>Make recommendation by random walk with restart. Basic algorithm is as follows:</p><ol><li>Get items that are already consumed by the user (on the graph, they are connected by one step). We denote them by <span>$q \in Q$</span>.</li><li>Starting from each node <span>$q \in Q$</span>, perform multiple random walks with certain stop probability. Record the visited count of the items on the walk. We denote the counts of item <span>$p$</span> on the walk from <span>$q$</span> by <span>$V_q[p]$</span>.</li><li>Finally aggregate <span>$V_q[p]$</span> to <span>$V[p]$</span>, and recommeds top-scored items. Two mothods for aggregation are provided</li></ol><ul><li>Simple aggregation: Taking sum, <span>$V[p] = \sum_{q\in Q} V_q[p]$</span>. You can also replace <code>sum</code> by, for instance, <code>maximum</code>.</li><li>Pixie boosting: <span>$V[p] = (\sum_{q\in Q} \sqrt{V_q[p]})^2$</span>, putting more importance on the nodes visited by <span>$q$</span>s.</li></ul><p><strong>Model-specific arguments</strong></p><ul><li><code>terminate_prob</code>: stop probability of one random walk</li><li><code>total_walk_length</code>: total walk length over the multiple walks from <span>$q$</span>&#39;s.</li><li><code>high_visited_count_threshold</code>: early stopping paramerer. Count up <code>high_visited_count</code> when the visited count of certain node reaches this threshold.</li><li><code>min_high_visited_candidates</code>: early stopping parameter. Terminate the walk from some node <span>$q$</span> if <code>high_visited_count</code> reaches <code>min_high_visited_candidates</code>.</li><li><code>pixie_walk_length_scaling</code>: If set to true, the start node <span>$q$</span> with more degree will be given more walk length. If false, the walk length is the same over all the nodes <span>$q \in Q$</span></li><li><code>pixie_multi_hit_boosting</code>: If true, pixie boosting is adopted for aggregation. If false, simple aggregation is used.</li><li><code>aggregate_function</code>: function used by simple aggregation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/yng87/Recommenders.jl/blob/4042a6ca8566b1a65dd619f7a2ebe297a0b9410f/src/model/randomwalk.jl#LL44-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting started</a><a class="docs-footer-nextpage" href="../metrics/">Metrics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Friday 24 September 2021 01:26">Friday 24 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
